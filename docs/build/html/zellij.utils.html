<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>zellij.utils package &mdash; Zellij 0.0.2 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> Zellij
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">zellij.utils package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-zellij.utils.benchmark">zellij.utils.benchmark module</a></li>
<li><a class="reference internal" href="#module-zellij.utils.fractal">zellij.utils.fractal module</a></li>
<li><a class="reference internal" href="#module-zellij.utils.heuristics">zellij.utils.heuristics module</a></li>
<li><a class="reference internal" href="#module-zellij.utils.loss_func">zellij.utils.loss_func module</a></li>
<li><a class="reference internal" href="#module-zellij.utils.search_space">zellij.utils.search_space module</a></li>
<li><a class="reference internal" href="#zellij-utils-tree-search-module">zellij.utils.tree_search module</a></li>
<li><a class="reference internal" href="#module-zellij.utils">Module contents</a></li>
</ul>
</li>
</ul>
</div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Zellij</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>zellij.utils package</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/zellij.utils.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="zellij-utils-package">
<h1>zellij.utils package<a class="headerlink" href="#zellij-utils-package" title="Permalink to this headline"></a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline"></a></h2>
</section>
<section id="module-zellij.utils.benchmark">
<span id="zellij-utils-benchmark-module"></span><h2>zellij.utils.benchmark module<a class="headerlink" href="#module-zellij.utils.benchmark" title="Permalink to this headline"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="zellij.utils.benchmark.ackley">
<span class="sig-prename descclassname"><span class="pre">zellij.utils.benchmark.</span></span><span class="sig-name descname"><span class="pre">ackley</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1100</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.benchmark.ackley" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="zellij.utils.benchmark.alpine">
<span class="sig-prename descclassname"><span class="pre">zellij.utils.benchmark.</span></span><span class="sig-name descname"><span class="pre">alpine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.benchmark.alpine" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="zellij.utils.benchmark.brown">
<span class="sig-prename descclassname"><span class="pre">zellij.utils.benchmark.</span></span><span class="sig-name descname"><span class="pre">brown</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.benchmark.brown" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="zellij.utils.benchmark.happycat">
<span class="sig-prename descclassname"><span class="pre">zellij.utils.benchmark.</span></span><span class="sig-name descname"><span class="pre">happycat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.benchmark.happycat" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="zellij.utils.benchmark.himmelblau">
<span class="sig-prename descclassname"><span class="pre">zellij.utils.benchmark.</span></span><span class="sig-name descname"><span class="pre">himmelblau</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.benchmark.himmelblau" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="zellij.utils.benchmark.random">
<span class="sig-prename descclassname"><span class="pre">zellij.utils.benchmark.</span></span><span class="sig-name descname"><span class="pre">random</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.benchmark.random" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="zellij.utils.benchmark.shifted_cigar_bent">
<span class="sig-prename descclassname"><span class="pre">zellij.utils.benchmark.</span></span><span class="sig-name descname"><span class="pre">shifted_cigar_bent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.benchmark.shifted_cigar_bent" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="zellij.utils.benchmark.shifted_levy">
<span class="sig-prename descclassname"><span class="pre">zellij.utils.benchmark.</span></span><span class="sig-name descname"><span class="pre">shifted_levy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.benchmark.shifted_levy" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="zellij.utils.benchmark.shifted_rastrigin">
<span class="sig-prename descclassname"><span class="pre">zellij.utils.benchmark.</span></span><span class="sig-name descname"><span class="pre">shifted_rastrigin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.benchmark.shifted_rastrigin" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="zellij.utils.benchmark.shifted_rotated_rosenbrock">
<span class="sig-prename descclassname"><span class="pre">zellij.utils.benchmark.</span></span><span class="sig-name descname"><span class="pre">shifted_rotated_rosenbrock</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">700</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.benchmark.shifted_rotated_rosenbrock" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</section>
<section id="module-zellij.utils.fractal">
<span id="zellij-utils-fractal-module"></span><h2>zellij.utils.fractal module<a class="headerlink" href="#module-zellij.utils.fractal" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="zellij.utils.fractal.Direct">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">zellij.utils.fractal.</span></span><span class="sig-name descname"><span class="pre">Direct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">father</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lo_bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">up_bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.75</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">children</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">score</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.fractal.Direct" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#zellij.utils.fractal.Fractal" title="zellij.utils.fractal.Fractal"><code class="xref py py-class docutils literal notranslate"><span class="pre">zellij.utils.fractal.Fractal</span></code></a></p>
<p>Dividing Rectangles. This section must be completed.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="zellij.utils.fractal.Direct.dim">
<span class="sig-name descname"><span class="pre">dim</span></span><a class="headerlink" href="#zellij.utils.fractal.Direct.dim" title="Permalink to this definition"></a></dt>
<dd><p>Number of dimensions</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="zellij.utils.fractal.Direct.create_children">
<span class="sig-name descname"><span class="pre">create_children</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.fractal.Direct.create_children" title="Permalink to this definition"></a></dt>
<dd><p>Method which defines how to build children Hyper-rectangles based on the current Hyper-rectangle.</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">LossFunc</span></code></dt><dd><p>Defines what a loss function is</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tree_search</span></code></dt><dd><p>Defines how to explore and exploit a fractal rooted tree.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">SearchSpace</span></code></dt><dd><p>Initial search space used to build fractal.</p>
</dd>
<dt><a class="reference internal" href="#zellij.utils.fractal.Fractal" title="zellij.utils.fractal.Fractal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Fractal</span></code></a></dt><dd><p>Parent class. Basic object to define what a fractal is.</p>
</dd>
<dt><a class="reference internal" href="#zellij.utils.fractal.Hypercube" title="zellij.utils.fractal.Hypercube"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Hypercube</span></code></a></dt><dd><p>Another hypervolume, with different properties</p>
</dd>
</dl>
</div>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_point</span></code>(self, score, solution)</p></td>
<td><p>This method adds a point associated to its evaluation by the loss function (f(solution)=score), to the historic of the fractal,         and determine if this point is the best one among all evaluated points inside the fractal.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#id0" title="zellij.utils.fractal.Direct.create_children"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_children</span></code></a>(self)</p></td>
<td><p>Abstract method which will create children of the current Fractal object, according to certain rules (Hypercube, Hypersphere...)</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="id0">
<span class="sig-name descname"><span class="pre">create_children</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#id0" title="Permalink to this definition"></a></dt>
<dd><p>Abstract method which will create children of the current Fractal object, according to certain rules (Hypercube, Hypersphere…)</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="zellij.utils.fractal.Fractal">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">zellij.utils.fractal.</span></span><span class="sig-name descname"><span class="pre">Fractal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lo_bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">up_bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">father</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">children</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">score</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.fractal.Fractal" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Fractal is an abstract class used in Fractal Decomposition. This class is used to build a rooted tree of fractals. Each object contains a reference to its father, references to its children, its bounds,    and its heuristic value (the score) computed after each exploration. Fractals are simplified and continuous subspaces, builded thanks to the original SearchSpace object.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="zellij.utils.fractal.Fractal.lo_bounds">
<span class="sig-name descname"><span class="pre">lo_bounds</span></span><a class="headerlink" href="#zellij.utils.fractal.Fractal.lo_bounds" title="Permalink to this definition"></a></dt>
<dd><p>Contains the lower bounds for each dimension of the fractal. Each fractal is bounded by its circumscribed hypercube.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list[float]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="zellij.utils.fractal.Fractal.up_bounds">
<span class="sig-name descname"><span class="pre">up_bounds</span></span><a class="headerlink" href="#zellij.utils.fractal.Fractal.up_bounds" title="Permalink to this definition"></a></dt>
<dd><p>Contains the upper bounds for each dimension of the fractal. Each fractal is bounded by its circumscribed hypercube.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list[float]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="zellij.utils.fractal.Fractal.id">
<span class="sig-name descname"><span class="pre">id</span></span><a class="headerlink" href="#zellij.utils.fractal.Fractal.id" title="Permalink to this definition"></a></dt>
<dd><p>Identifier of a fractal. Combined to the id of itf parents, the id is unique.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="zellij.utils.fractal.Fractal.father">
<span class="sig-name descname"><span class="pre">father</span></span><a class="headerlink" href="#zellij.utils.fractal.Fractal.father" title="Permalink to this definition"></a></dt>
<dd><p>Reference to the parent of the current fractal.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#zellij.utils.fractal.Fractal" title="zellij.utils.fractal.Fractal">Fractal</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="zellij.utils.fractal.Fractal.children">
<span class="sig-name descname"><span class="pre">children</span></span><a class="headerlink" href="#zellij.utils.fractal.Fractal.children" title="Permalink to this definition"></a></dt>
<dd><p>References to all children of the current fractal.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list[<a class="reference internal" href="#zellij.utils.fractal.Fractal" title="zellij.utils.fractal.Fractal">Fractal</a>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="zellij.utils.fractal.Fractal.score">
<span class="sig-name descname"><span class="pre">score</span></span><a class="headerlink" href="#zellij.utils.fractal.Fractal.score" title="Permalink to this definition"></a></dt>
<dd><p>Heuristic value associated to the fractal after an exploration</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>{float, int}</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="zellij.utils.fractal.Fractal.level">
<span class="sig-name descname"><span class="pre">level</span></span><a class="headerlink" href="#zellij.utils.fractal.Fractal.level" title="Permalink to this definition"></a></dt>
<dd><p>Current level of the fractal in the rooted tree. See Tree_search.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="zellij.utils.fractal.Fractal.min_score">
<span class="sig-name descname"><span class="pre">min_score</span></span><a class="headerlink" href="#zellij.utils.fractal.Fractal.min_score" title="Permalink to this definition"></a></dt>
<dd><p>Score associated to the best found solution inside the fractal</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>{float, int}</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="zellij.utils.fractal.Fractal.best_sol">
<span class="sig-name descname"><span class="pre">best_sol</span></span><a class="headerlink" href="#zellij.utils.fractal.Fractal.best_sol" title="Permalink to this definition"></a></dt>
<dd><p>Best found solution inside the fractal in its mixed format.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list[{float, int, str}]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="zellij.utils.fractal.Fractal.best_sol_c">
<span class="sig-name descname"><span class="pre">best_sol_c</span></span><a class="headerlink" href="#zellij.utils.fractal.Fractal.best_sol_c" title="Permalink to this definition"></a></dt>
<dd><p>Best found solution inside the fractal in its continuous format.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list[float]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="zellij.utils.fractal.Fractal.all_solutions">
<span class="sig-name descname"><span class="pre">all_solutions</span></span><a class="headerlink" href="#zellij.utils.fractal.Fractal.all_solutions" title="Permalink to this definition"></a></dt>
<dd><p>Historic of all evaluated solutions inside the fractal.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="zellij.utils.fractal.Fractal.all_scores">
<span class="sig-name descname"><span class="pre">all_scores</span></span><a class="headerlink" href="#zellij.utils.fractal.Fractal.all_scores" title="Permalink to this definition"></a></dt>
<dd><p>Historic of all evaluated scores inside the fractal..</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="zellij.utils.fractal.Fractal.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lo_bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">up_bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">father</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">children</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">score</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.fractal.Fractal.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize Fractal class</p>
</dd></dl>

<dl class="simple">
<dt>add_point(self,score, solution)</dt><dd><p>Adds a point to the fractal</p>
</dd>
<dt>create_children(self)</dt><dd><p>Abstract method which defines how fractal children should be created</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">LossFunc</span></code></dt><dd><p>Defines what a loss function is</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tree_search</span></code></dt><dd><p>Defines how to explore and exploit a fractal rooted tree.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">SearchSpace</span></code></dt><dd><p>Initial search space used to build fractal.</p>
</dd>
<dt><a class="reference internal" href="#zellij.utils.fractal.Hypercube" title="zellij.utils.fractal.Hypercube"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Hypercube</span></code></a></dt><dd><p>Inherited Fractal type</p>
</dd>
<dt><a class="reference internal" href="#zellij.utils.fractal.Hypersphere" title="zellij.utils.fractal.Hypersphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Hypersphere</span></code></a></dt><dd><p>Inherited Fractal type</p>
</dd>
</dl>
</div>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#zellij.utils.fractal.Fractal.add_point" title="zellij.utils.fractal.Fractal.add_point"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_point</span></code></a>(self, score, solution)</p></td>
<td><p>This method adds a point associated to its evaluation by the loss function (f(solution)=score), to the historic of the fractal,         and determine if this point is the best one among all evaluated points inside the fractal.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#zellij.utils.fractal.Fractal.create_children" title="zellij.utils.fractal.Fractal.create_children"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_children</span></code></a>(self)</p></td>
<td><p>Abstract method which will create children of the current Fractal object, according to certain rules (Hypercube, Hypersphere...)</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="zellij.utils.fractal.Fractal.add_point">
<span class="sig-name descname"><span class="pre">add_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">score</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solution</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.fractal.Fractal.add_point" title="Permalink to this definition"></a></dt>
<dd><p>This method adds a point associated to its evaluation by the loss function (f(solution)=score), to the historic of the fractal,         and determine if this point is the best one among all evaluated points inside the fractal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>score</strong> (<em>{int</em><em>, </em><em>float}</em>) – Score associated to the evaluated solution</p></li>
<li><p><strong>solution</strong> (<em>list</em><em>[</em><em>{int</em><em>, </em><em>float</em><em>, </em><em>str}</em><em>]</em>) – It corresponds to a point in the mixed format inside the fractal and associated to its evaluation (score).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="zellij.utils.fractal.Fractal.create_children">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">create_children</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.fractal.Fractal.create_children" title="Permalink to this definition"></a></dt>
<dd><p>Abstract method which will create children of the current Fractal object, according to certain rules (Hypercube, Hypersphere…)</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="zellij.utils.fractal.Hypercube">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">zellij.utils.fractal.</span></span><span class="sig-name descname"><span class="pre">Hypercube</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">father</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lo_bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">up_bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">children</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">score</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.fractal.Hypercube" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#zellij.utils.fractal.Fractal" title="zellij.utils.fractal.Fractal"><code class="xref py py-class docutils literal notranslate"><span class="pre">zellij.utils.fractal.Fractal</span></code></a></p>
<p>The hypercube is a basic hypervolume to decompose the SearchSpace. It’s also one of the most computationally inefficient in high dimension.    The decomposition complexity of an Hypercube with equalsize Hypercubes, is equal to $2^d$, d is the dimension.    However building a single hypercube is low complexity task, and the space coverage is very good, 100% of the initial hypercube is covered by its children.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="zellij.utils.fractal.Hypercube.dim">
<span class="sig-name descname"><span class="pre">dim</span></span><a class="headerlink" href="#zellij.utils.fractal.Hypercube.dim" title="Permalink to this definition"></a></dt>
<dd><p>Number of dimensions</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="zellij.utils.fractal.Hypercube.create_children">
<span class="sig-name descname"><span class="pre">create_children</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.fractal.Hypercube.create_children" title="Permalink to this definition"></a></dt>
<dd><p>Method which defines how to build children Hypercubes based on the current Hypercube.</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">LossFunc</span></code></dt><dd><p>Defines what a loss function is</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tree_search</span></code></dt><dd><p>Defines how to explore and exploit a fractal rooted tree.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">SearchSpace</span></code></dt><dd><p>Initial search space used to build fractal.</p>
</dd>
<dt><a class="reference internal" href="#zellij.utils.fractal.Fractal" title="zellij.utils.fractal.Fractal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Fractal</span></code></a></dt><dd><p>Parent class. Basic object to define what a fractal is.</p>
</dd>
<dt><a class="reference internal" href="#zellij.utils.fractal.Hypersphere" title="zellij.utils.fractal.Hypersphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Hypersphere</span></code></a></dt><dd><p>Another hypervolume, with different properties</p>
</dd>
</dl>
</div>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_point</span></code>(self, score, solution)</p></td>
<td><p>This method adds a point associated to its evaluation by the loss function (f(solution)=score), to the historic of the fractal,         and determine if this point is the best one among all evaluated points inside the fractal.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#id1" title="zellij.utils.fractal.Hypercube.create_children"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_children</span></code></a>(self)</p></td>
<td><p>Method which defines how to build children Hypercubes based on the current Hypercube.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="id1">
<span class="sig-name descname"><span class="pre">create_children</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#id1" title="Permalink to this definition"></a></dt>
<dd><p>Method which defines how to build children Hypercubes based on the current Hypercube.
It uses Hyperplan bisecting to build children. To build an Hypercube, it only requires lower and upper bounds.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="zellij.utils.fractal.Hypersphere">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">zellij.utils.fractal.</span></span><span class="sig-name descname"><span class="pre">Hypersphere</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">father</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lo_bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">up_bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inflation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.75</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">children</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">score</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.fractal.Hypersphere" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#zellij.utils.fractal.Fractal" title="zellij.utils.fractal.Fractal"><code class="xref py py-class docutils literal notranslate"><span class="pre">zellij.utils.fractal.Fractal</span></code></a></p>
<p>The Hypersphere is a basic hypervolume to decompose the SearchSpace. It is one of the most computationally efficient, to decompose the SearchSpace.
To decompose an hypersphere by equalsize hypersphere the complexity is equal to $2*d$, d is the dimension, moreover building an hypersphere is easy, it only needs a center and its radius.
However the space coverage is poor, indeed the volume of an hypersphere tends to 0, when the dimension tends to infinity. To partially tackle this problem, an inflation rate allows bigger hypersphere,
but this will create overlapping hypervolumes.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="zellij.utils.fractal.Hypersphere.dim">
<span class="sig-name descname"><span class="pre">dim</span></span><a class="headerlink" href="#zellij.utils.fractal.Hypersphere.dim" title="Permalink to this definition"></a></dt>
<dd><p>Number of dimensions</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="zellij.utils.fractal.Hypersphere.inflation">
<span class="sig-name descname"><span class="pre">inflation</span></span><a class="headerlink" href="#zellij.utils.fractal.Hypersphere.inflation" title="Permalink to this definition"></a></dt>
<dd><p>Inflation rate of hyperspheres. Be carefull a too large inflation can result to hypersphere with identical center and radius.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="zellij.utils.fractal.Hypersphere.center">
<span class="sig-name descname"><span class="pre">center</span></span><a class="headerlink" href="#zellij.utils.fractal.Hypersphere.center" title="Permalink to this definition"></a></dt>
<dd><p>List of floats containing the coordinates</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list[float]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="zellij.utils.fractal.Hypersphere.radius">
<span class="sig-name descname"><span class="pre">radius</span></span><a class="headerlink" href="#zellij.utils.fractal.Hypersphere.radius" title="Permalink to this definition"></a></dt>
<dd><p>List of floats containing the radius for each dimension (in case the initial SearchSpace is not an hypercube).</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list[float]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="zellij.utils.fractal.Hypersphere.create_children">
<span class="sig-name descname"><span class="pre">create_children</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.fractal.Hypersphere.create_children" title="Permalink to this definition"></a></dt>
<dd><p>Method which defines how to build children Hyperspheres based on the current Hypersphere.</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">LossFunc</span></code></dt><dd><p>Defines what a loss function is</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Tree_search</span></code></dt><dd><p>Defines how to explore and exploit a fractal rooted tree.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">SearchSpace</span></code></dt><dd><p>Initial search space used to build fractal.</p>
</dd>
<dt><a class="reference internal" href="#zellij.utils.fractal.Fractal" title="zellij.utils.fractal.Fractal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Fractal</span></code></a></dt><dd><p>Parent class. Basic object to define what a fractal is.</p>
</dd>
<dt><a class="reference internal" href="#zellij.utils.fractal.Hypercube" title="zellij.utils.fractal.Hypercube"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Hypercube</span></code></a></dt><dd><p>Another hypervolume, with different properties</p>
</dd>
</dl>
</div>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_point</span></code>(self, score, solution)</p></td>
<td><p>This method adds a point associated to its evaluation by the loss function (f(solution)=score), to the historic of the fractal,         and determine if this point is the best one among all evaluated points inside the fractal.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#id2" title="zellij.utils.fractal.Hypersphere.create_children"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_children</span></code></a>(self)</p></td>
<td><p>Method which defines how to build children Hypercubes based on the current Hypercube.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="id2">
<span class="sig-name descname"><span class="pre">create_children</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#id2" title="Permalink to this definition"></a></dt>
<dd><p>Method which defines how to build children Hypercubes based on the current Hypercube.
It uses Hyperplan bisecting to build children. To build an Hypercube, it only requires lower and upper bounds.</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-zellij.utils.heuristics">
<span id="zellij-utils-heuristics-module"></span><h2>zellij.utils.heuristics module<a class="headerlink" href="#module-zellij.utils.heuristics" title="Permalink to this headline"></a></h2>
</section>
<section id="module-zellij.utils.loss_func">
<span id="zellij-utils-loss-func-module"></span><h2>zellij.utils.loss_func module<a class="headerlink" href="#module-zellij.utils.loss_func" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="zellij.utils.loss_func.FDA_loss_func">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">zellij.utils.loss_func.</span></span><span class="sig-name descname"><span class="pre">FDA_loss_func</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">H</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.loss_func.FDA_loss_func" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>FDA_loss_func allows to wrap function of type f(x)=(y, model), so it can be used in by the Fractal Decomposition Algorithm.</p>
<p>Must be modified</p>
<p class="rubric">Methods</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 55%" />
<col style="width: 45%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>evaluate</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="zellij.utils.loss_func.FDA_loss_func.evaluate">
<span class="sig-name descname"><span class="pre">evaluate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.loss_func.FDA_loss_func.evaluate" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="zellij.utils.loss_func.Loss">
<span class="sig-prename descclassname"><span class="pre">zellij.utils.loss_func.</span></span><span class="sig-name descname"><span class="pre">Loss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_model</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">MPI</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.loss_func.Loss" title="Permalink to this definition"></a></dt>
<dd><p>Wrap a function of type f(x)=y. See LossFunc for more info.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<em>function</em><em>, </em><em>default=None</em>) – Function of type f(x)=y. x must be a solution. A solution can be a list of float, int… It can also be of mixed types, containing, strings, float, int…</p></li>
<li><p><strong>save_model</strong> (<em>string</em><em>, </em><em>default=''</em>) – Filename where to save the best found model. Only one model is saved for memory issues.</p></li>
<li><p><strong>MPI</strong> (<em>boolean</em><em>, </em><em>default=False</em>) – Wrap the function with MPILoss if True, with SerialLoss else.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>wrapper</strong> – Wrapped original function</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#zellij.utils.loss_func.LossFunc" title="zellij.utils.loss_func.LossFunc">LossFunc</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="zellij.utils.loss_func.LossFunc">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">zellij.utils.loss_func.</span></span><span class="sig-name descname"><span class="pre">LossFunc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_model</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.loss_func.LossFunc" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>LossFunc allows to wrap function of type f(x)=(y, model), so it can be used in Zellij by adding several features,     such as calls count, saving, parallelization, historic… y is the results of the evaluation of x by f. model is optional, if you want to save the best found model (e.g. a neural network)     you can return the model. However the model must have a “save” method (e.g. model.save(filename)).</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="zellij.utils.loss_func.LossFunc.model">
<span class="sig-name descname"><span class="pre">model</span></span><a class="headerlink" href="#zellij.utils.loss_func.LossFunc.model" title="Permalink to this definition"></a></dt>
<dd><p>Function of type f(x)=y. x must be a solution. A solution can be a list of float, int… It can also be of mixed types, containing, strings, float, int…</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>function</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="zellij.utils.loss_func.LossFunc.save_model">
<span class="sig-name descname"><span class="pre">save_model</span></span><a class="headerlink" href="#zellij.utils.loss_func.LossFunc.save_model" title="Permalink to this definition"></a></dt>
<dd><p>Filename where to save the best found model. Only one model is saved for memory issues.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>string</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="zellij.utils.loss_func.LossFunc.best_score">
<span class="sig-name descname"><span class="pre">best_score</span></span><a class="headerlink" href="#zellij.utils.loss_func.LossFunc.best_score" title="Permalink to this definition"></a></dt>
<dd><p>Best found score among all loss function evaluations.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id3">
<span class="sig-name descname"><span class="pre">best_score</span></span><a class="headerlink" href="#id3" title="Permalink to this definition"></a></dt>
<dd><p>Best found score among all loss function evaluations.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="zellij.utils.loss_func.LossFunc.best_sol">
<span class="sig-name descname"><span class="pre">best_sol</span></span><a class="headerlink" href="#zellij.utils.loss_func.LossFunc.best_sol" title="Permalink to this definition"></a></dt>
<dd><p>Best found solution among all loss function evaluations.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="zellij.utils.loss_func.LossFunc.all_scores">
<span class="sig-name descname"><span class="pre">all_scores</span></span><a class="headerlink" href="#zellij.utils.loss_func.LossFunc.all_scores" title="Permalink to this definition"></a></dt>
<dd><p>Historic of all evaluated scores.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="zellij.utils.loss_func.LossFunc.all_solutions">
<span class="sig-name descname"><span class="pre">all_solutions</span></span><a class="headerlink" href="#zellij.utils.loss_func.LossFunc.all_solutions" title="Permalink to this definition"></a></dt>
<dd><p>Historic of all evaluated solutions.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="zellij.utils.loss_func.LossFunc.calls">
<span class="sig-name descname"><span class="pre">calls</span></span><a class="headerlink" href="#zellij.utils.loss_func.LossFunc.calls" title="Permalink to this definition"></a></dt>
<dd><p>Number of loss function calls</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="zellij.utils.loss_func.LossFunc.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.loss_func.LossFunc.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize LossFunc class</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="zellij.utils.loss_func.LossFunc._save_file">
<span class="sig-name descname"><span class="pre">_save_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solution</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">score</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">add</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">others</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.loss_func.LossFunc._save_file" title="Permalink to this definition"></a></dt>
<dd><p>Save informations into a file created by a Metaheuristic.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="zellij.utils.loss_func.LossFunc._save_best">
<span class="sig-name descname"><span class="pre">_save_best</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solution</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">score</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.loss_func.LossFunc._save_best" title="Permalink to this definition"></a></dt>
<dd><p>Save best found solution and score into self.</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#zellij.utils.loss_func.Loss" title="zellij.utils.loss_func.Loss"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Loss</span></code></a></dt><dd><p>Wrapper function</p>
</dd>
<dt><a class="reference internal" href="#zellij.utils.loss_func.MPILoss" title="zellij.utils.loss_func.MPILoss"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MPILoss</span></code></a></dt><dd><p>Distributed version of LossFunc</p>
</dd>
<dt><a class="reference internal" href="#zellij.utils.loss_func.SerialLoss" title="zellij.utils.loss_func.SerialLoss"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SerialLoss</span></code></a></dt><dd><p>Basic version of LossFunc</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="zellij.utils.loss_func.MPILoss">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">zellij.utils.loss_func.</span></span><span class="sig-name descname"><span class="pre">MPILoss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_model</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.loss_func.MPILoss" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#zellij.utils.loss_func.LossFunc" title="zellij.utils.loss_func.LossFunc"><code class="xref py py-class docutils literal notranslate"><span class="pre">zellij.utils.loss_func.LossFunc</span></code></a></p>
<p>MPILoss allows to wrap function of type f(x)=(y, model). MPILoss adds method to distribute dynamically the evaluation of multiple solutions.
It does not distribute the original loss function itself</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="zellij.utils.loss_func.MPILoss.comm">
<span class="sig-name descname"><span class="pre">comm</span></span><a class="headerlink" href="#zellij.utils.loss_func.MPILoss.comm" title="Permalink to this definition"></a></dt>
<dd><p>All created processes and their communication context are grouped in comm.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>MPI_COMM_WORLD</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="zellij.utils.loss_func.MPILoss.status">
<span class="sig-name descname"><span class="pre">status</span></span><a class="headerlink" href="#zellij.utils.loss_func.MPILoss.status" title="Permalink to this definition"></a></dt>
<dd><p>Data structure containing information about a received message.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>MPI_Status</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="zellij.utils.loss_func.MPILoss.rank">
<span class="sig-name descname"><span class="pre">rank</span></span><a class="headerlink" href="#zellij.utils.loss_func.MPILoss.rank" title="Permalink to this definition"></a></dt>
<dd><p>Process rank</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="zellij.utils.loss_func.MPILoss.p">
<span class="sig-name descname"><span class="pre">p</span></span><a class="headerlink" href="#zellij.utils.loss_func.MPILoss.p" title="Permalink to this definition"></a></dt>
<dd><p>comm size</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="zellij.utils.loss_func.MPILoss.master">
<span class="sig-name descname"><span class="pre">master</span></span><a class="headerlink" href="#zellij.utils.loss_func.MPILoss.master" title="Permalink to this definition"></a></dt>
<dd><p>If True the process is the master, else it is the worker.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>boolean</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="zellij.utils.loss_func.MPILoss.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.loss_func.MPILoss.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize MPILoss class.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="zellij.utils.loss_func.MPILoss.__call__">
<span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename=''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">\*\*kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.loss_func.MPILoss.__call__" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate a list X of solutions with the original loss function.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="zellij.utils.loss_func.MPILoss.worker">
<span class="sig-name descname"><span class="pre">worker</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.loss_func.MPILoss.worker" title="Permalink to this definition"></a></dt>
<dd><p>Initialize a worker.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="zellij.utils.loss_func.MPILoss.stop">
<span class="sig-name descname"><span class="pre">stop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.loss_func.MPILoss.stop" title="Permalink to this definition"></a></dt>
<dd><p>Stops all the workers and master.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="zellij.utils.loss_func.MPILoss._save_model">
<span class="sig-name descname"><span class="pre">_save_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">score</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.loss_func.MPILoss._save_model" title="Permalink to this definition"></a></dt>
<dd><p>See LossFunc, save a model according to its score and the worker rank.</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#zellij.utils.loss_func.Loss" title="zellij.utils.loss_func.Loss"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Loss</span></code></a></dt><dd><p>Wrapper function</p>
</dd>
<dt><a class="reference internal" href="#zellij.utils.loss_func.LossFunc" title="zellij.utils.loss_func.LossFunc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LossFunc</span></code></a></dt><dd><p>Inherited class</p>
</dd>
<dt><a class="reference internal" href="#zellij.utils.loss_func.SerialLoss" title="zellij.utils.loss_func.SerialLoss"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SerialLoss</span></code></a></dt><dd><p>Basic version of LossFunc</p>
</dd>
</dl>
</div>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#zellij.utils.loss_func.MPILoss.__call__" title="zellij.utils.loss_func.MPILoss.__call__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code></a>(self, model[, save_model])</p></td>
<td><p>Evaluate a list X of solutions with the original loss function.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#id4" title="zellij.utils.loss_func.MPILoss.stop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stop</span></code></a>(self)</p></td>
<td><p>Send a stop message to all workers.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#id5" title="zellij.utils.loss_func.MPILoss.worker"><code class="xref py py-obj docutils literal notranslate"><span class="pre">worker</span></code></a>(self)</p></td>
<td><p>Initialize worker.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="id4">
<span class="sig-name descname"><span class="pre">stop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#id4" title="Permalink to this definition"></a></dt>
<dd><p>Send a stop message to all workers.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id5">
<span class="sig-name descname"><span class="pre">worker</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#id5" title="Permalink to this definition"></a></dt>
<dd><p>Initialize worker. Whilte it does not receive a stop message, a worker will wait for a solution to evaluate.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="zellij.utils.loss_func.SerialLoss">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">zellij.utils.loss_func.</span></span><span class="sig-name descname"><span class="pre">SerialLoss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_model</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.loss_func.SerialLoss" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#zellij.utils.loss_func.LossFunc" title="zellij.utils.loss_func.LossFunc"><code class="xref py py-class docutils literal notranslate"><span class="pre">zellij.utils.loss_func.LossFunc</span></code></a></p>
<p>SerialLoss allows to wrap function of type f(x)=(y, model). SerialLoss adds methods to save and evaluate the original loss function.</p>
<dl class="py method">
<dt class="sig sig-object py" id="zellij.utils.loss_func.SerialLoss.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.loss_func.SerialLoss.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize MPILoss class.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="zellij.utils.loss_func.SerialLoss.__call__">
<span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename=''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">\*\*kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.loss_func.SerialLoss.__call__" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate a list X of solutions with the original loss function.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="zellij.utils.loss_func.SerialLoss._save_model">
<span class="sig-name descname"><span class="pre">_save_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">score</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.loss_func.SerialLoss._save_model" title="Permalink to this definition"></a></dt>
<dd><p>See LossFunc, save a model according to its score and the worker rank.</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#zellij.utils.loss_func.Loss" title="zellij.utils.loss_func.Loss"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Loss</span></code></a></dt><dd><p>Wrapper function</p>
</dd>
<dt><a class="reference internal" href="#zellij.utils.loss_func.LossFunc" title="zellij.utils.loss_func.LossFunc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LossFunc</span></code></a></dt><dd><p>Inherited class</p>
</dd>
<dt><a class="reference internal" href="#zellij.utils.loss_func.MPILoss" title="zellij.utils.loss_func.MPILoss"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MPILoss</span></code></a></dt><dd><p>Distributed version of LossFunc</p>
</dd>
</dl>
</div>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#zellij.utils.loss_func.SerialLoss.__call__" title="zellij.utils.loss_func.SerialLoss.__call__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code></a>(self, model[, save_model])</p></td>
<td><p>Evaluate a list X of solutions with the original loss function.</p></td>
</tr>
</tbody>
</table>
</dd></dl>

</section>
<section id="module-zellij.utils.search_space">
<span id="zellij-utils-search-space-module"></span><h2>zellij.utils.search_space module<a class="headerlink" href="#module-zellij.utils.search_space" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="zellij.utils.search_space.Searchspace">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">zellij.utils.search_space.</span></span><span class="sig-name descname"><span class="pre">Searchspace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">types</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighborhood</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.search_space.Searchspace" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Search is an essential class for Zellij. You can determine your search space with this object.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="zellij.utils.search_space.Searchspace.label">
<span class="sig-name descname"><span class="pre">label</span></span><a class="headerlink" href="#zellij.utils.search_space.Searchspace.label" title="Permalink to this definition"></a></dt>
<dd><p>Labels associated to each dimension of the search space</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list[str]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="zellij.utils.search_space.Searchspace.type">
<span class="sig-name descname"><span class="pre">type</span></span><a class="headerlink" href="#zellij.utils.search_space.Searchspace.type" title="Permalink to this definition"></a></dt>
<dd><p>Types associated to each dimension of the search space.
R : Real dimension (e.g. float)
D : Discrete dimension (e.g. int)
C : Categorical dimension (e.g. {‘dog’, ‘cats’, ‘rabbit’})
K : Constant dimension, used to define an unvariable dimension.          Used in space decomposition when a dimension cannot be decomposed because it became too small (e.g. discrete).         For a constant value, implementing it directly to the loss function is preferable.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list[{‘R’,’D’,’C’,’K’}]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="zellij.utils.search_space.Searchspace.values">
<span class="sig-name descname"><span class="pre">values</span></span><a class="headerlink" href="#zellij.utils.search_space.Searchspace.values" title="Permalink to this definition"></a></dt>
<dd><p>Bounds associated to each dimension.        For R, D types, values must be of form [a:{float,int}, b:{float,int}] with a &lt; b.        For C type, values must be of form [{str, int, float}, {str, int, float}…]
For K type, values can be of any type because it will not be used and only passed to the loss function.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list[{[float, float], [int, int], [{str, int, float}, {str, int, float}…]}]</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="zellij.utils.search_space.Searchspace.neighborhood">
<span class="sig-name descname"><span class="pre">neighborhood</span></span><a class="headerlink" href="#zellij.utils.search_space.Searchspace.neighborhood" title="Permalink to this definition"></a></dt>
<dd><p>Neighborhood  of a solution for each dimension. For a solution x=[v1, v2], bounds of the neighborhood of vi of x are computed by [max(vi-n, lower bound), min(vi+n, upper bound)],        except for C dimension, a neighbor is computed by drawing a random value assoiated to the dimension. For K dimension there is no neighborhood.</p>
<p>For R type, the neighborhood can be a float, or an int.
For D type, the neighborhood is an int.
For C,K types, the neighborhood must be -1.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list[{float, int, -1}]</p>
</dd>
</dl>
</dd></dl>

<dl class="simple">
<dt>sub_values<span class="classifier">list[{[float, float], [int, int], [{str, int, float}, {str, int, float}…]}]</span></dt><dd><p>When building a subspace. Original values are saved in sub_values, so it can easily convert a subspace into a mixed or continuous search space. See values</p>
</dd>
<dt>n_variables<span class="classifier">list</span></dt><dd><p>Number of dimensions</p>
</dd>
<dt>k_index<span class="classifier">list[int]</span></dt><dd><p>Indexes of constant dimensions.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="zellij.utils.search_space.Searchspace.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.search_space.Searchspace.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Initialize SearchSpace class</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="zellij.utils.search_space.Searchspace._create_neighborhood">
<span class="sig-name descname"><span class="pre">_create_neighborhood</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighborhood</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.search_space.Searchspace._create_neighborhood" title="Permalink to this definition"></a></dt>
<dd><p>Create the neighborhood. See Searchspace.__init__</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="zellij.utils.search_space.Searchspace.random_attribute">
<span class="sig-name descname"><span class="pre">random_attribute</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">replace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.search_space.Searchspace.random_attribute" title="Permalink to this definition"></a></dt>
<dd><p>Draw random features from the search space. Features of type K, cannot be drawn (i.e. their probability are set to 0).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="zellij.utils.search_space.Searchspace.random_value">
<span class="sig-name descname"><span class="pre">random_value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attribute</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">replace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.search_space.Searchspace.random_value" title="Permalink to this definition"></a></dt>
<dd><p>Draw random values of an attribute from the search space, using uniform distribution. Features of type K return their constant value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="zellij.utils.search_space.Searchspace._get_real_neighbor">
<span class="sig-name descname"><span class="pre">_get_real_neighbor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.search_space.Searchspace._get_real_neighbor" title="Permalink to this definition"></a></dt>
<dd><p>Draw a neighbor of a Real attribute from the search space, using uniform distribution. According to its lower and upper bounds</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="zellij.utils.search_space.Searchspace._get_discrete_neighbor">
<span class="sig-name descname"><span class="pre">_get_discrete_neighbor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.search_space.Searchspace._get_discrete_neighbor" title="Permalink to this definition"></a></dt>
<dd><p>Draw a neighbor of a Discrete attribute from the search space, using discrete uniform distribution. According to its lower and upper bounds</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="zellij.utils.search_space.Searchspace._get_categorical_neighbor">
<span class="sig-name descname"><span class="pre">_get_categorical_neighbor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.search_space.Searchspace._get_categorical_neighbor" title="Permalink to this definition"></a></dt>
<dd><p>Draw a neighbor of a Categorical attribute from the search space, using discrete uniform distribution. According to all its possible value</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="zellij.utils.search_space.Searchspace.get_neighbor">
<span class="sig-name descname"><span class="pre">get_neighbor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attribute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.search_space.Searchspace.get_neighbor" title="Permalink to this definition"></a></dt>
<dd><p>Draw a neighbor of an initial solution, according to the search space bounds and dimensions types.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="zellij.utils.search_space.Searchspace.random_point">
<span class="sig-name descname"><span class="pre">random_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.search_space.Searchspace.random_point" title="Permalink to this definition"></a></dt>
<dd><p>Return a random point from the search space</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="zellij.utils.search_space.Searchspace.convert_to_continuous">
<span class="sig-name descname"><span class="pre">convert_to_continuous</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sub_values</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.search_space.Searchspace.convert_to_continuous" title="Permalink to this definition"></a></dt>
<dd><p>Convert given points from mixed to continuous, or, from continuous to mixed.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="zellij.utils.search_space.Searchspace.general_convert">
<span class="sig-name descname"><span class="pre">general_convert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.search_space.Searchspace.general_convert" title="Permalink to this definition"></a></dt>
<dd><p>Convert the search space by building a continuous one.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="zellij.utils.search_space.Searchspace.subspace">
<span class="sig-name descname"><span class="pre">subspace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lo_bounds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">up_bounds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.search_space.Searchspace.subspace" title="Permalink to this definition"></a></dt>
<dd><p>Build a sub space according to the actual Searchspace using two vectors containing lower and upper bounds of the subspace.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="zellij.utils.search_space.Searchspace.show">
<span class="sig-name descname"><span class="pre">show</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.search_space.Searchspace.show" title="Permalink to this definition"></a></dt>
<dd><p>Show solutions X associated to their values Y, according to the Searchspace</p>
</dd></dl>

<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">LossFunc</span></code></dt><dd><p>Parent class for a loss function.</p>
</dd>
</dl>
</div>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#id6" title="zellij.utils.search_space.Searchspace.convert_to_continuous"><code class="xref py py-obj docutils literal notranslate"><span class="pre">convert_to_continuous</span></code></a>(self, points[, ...])</p></td>
<td><p>Convert given points from mixed to continuous, or, from continuous to mixed.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#id7" title="zellij.utils.search_space.Searchspace.general_convert"><code class="xref py py-obj docutils literal notranslate"><span class="pre">general_convert</span></code></a>()</p></td>
<td><p>Convert the search space by building a continuous one.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#id8" title="zellij.utils.search_space.Searchspace.get_neighbor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_neighbor</span></code></a>(self, point[, size, attribute])</p></td>
<td><p>Draw a neighbor of an initial solution, according to the search space bounds and dimensions types.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#id9" title="zellij.utils.search_space.Searchspace.random_attribute"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random_attribute</span></code></a>(self[, size, replace, exclude])</p></td>
<td><p>Draw random features from the search space.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#id10" title="zellij.utils.search_space.Searchspace.random_point"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random_point</span></code></a>(self[, size])</p></td>
<td><p>Return a random point from the search space</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#id11" title="zellij.utils.search_space.Searchspace.random_value"><code class="xref py py-obj docutils literal notranslate"><span class="pre">random_value</span></code></a>(self, attribute[, size, ...])</p></td>
<td><p>Draw random values of an attribute from the search space, using uniform distribution.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#id12" title="zellij.utils.search_space.Searchspace.show"><code class="xref py py-obj docutils literal notranslate"><span class="pre">show</span></code></a>(self, X, Y)</p></td>
<td><p>Show solutions X associated to their values Y, according to the Searchspace</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#id13" title="zellij.utils.search_space.Searchspace.subspace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subspace</span></code></a>(self, points[, reverse, sub_values])</p></td>
<td><p>Build a sub space according to the actual Searchspace using two vectors containing lower and upper bounds of the subspace. Transforms types to K if necessary. Builds an adaptated neighborhood to avoid large neighborhood compare to the subspace size. Categorical lower and upper bounds of the subspace are determined according to a slice of the vector containing values:     Original: [&quot;dog&quot;, &quot;cat&quot;, &quot;rabbit&quot;, &quot;horse&quot;]     lo_bounds = [&quot;dog&quot;]     up_bounds = [&quot;rabbit&quot;]     Subspace: [&quot;dog&quot;, &quot;cat&quot;, &quot;rabbit&quot;].</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="id6">
<span class="sig-name descname"><span class="pre">convert_to_continuous</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sub_values</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#id6" title="Permalink to this definition"></a></dt>
<dd><p>Convert given points from mixed to continuous, or, from continuous to mixed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> (<em>{list</em><em>[</em><em>list</em><em>[</em><em>{int</em><em>, </em><em>float</em><em>, </em><em>str}</em><em>, </em><em>{int</em><em>, </em><em>float</em><em>, </em><em>str}</em><em>...</em><em>]</em><em>, </em><em>...</em><em>]</em><em>, </em><em>list</em><em>[</em><em>list</em><em>[</em><em>float</em><em>, </em><em>float</em><em>...</em><em>]</em><em>, </em><em>...</em><em>]</em><em>}</em>) – List of points to convert</p></li>
<li><p><strong>reverse</strong> (<em>boolean</em><em>, </em><em>default=False</em>) – If False convert points from mixed to continuous, if True, from continuous to mixed</p></li>
<li><p><strong>sub_values</strong> (<em>boolean</em><em>, </em><em>default=True</em>) – If the search space is a subspace, uses the original values to convert if True, else uses its own bounds.
See Searchspace</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>points</strong> – List of converted points. Points are list of float if converted to continuous, else list of mixed variables.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>{list[list[{int, float, str}, {int, float, str}…], …], list[list[float, float…], …]}</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id7">
<span class="sig-name descname"><span class="pre">general_convert</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#id7" title="Permalink to this definition"></a></dt>
<dd><p>Convert the search space by building a continuous one.
labels are identical, all types are converted to R, and all bounds are between [0,1].
Build an adptated neighborhood</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>sp</strong> – Continuous Searchspace.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#zellij.utils.search_space.Searchspace" title="zellij.utils.search_space.Searchspace">Searchspace</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id8">
<span class="sig-name descname"><span class="pre">get_neighbor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attribute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#id8" title="Permalink to this definition"></a></dt>
<dd><p>Draw a neighbor of an initial solution, according to the search space bounds and dimensions types.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point</strong> (<em>list</em><em>[</em><em>{int</em><em>, </em><em>float</em><em>, </em><em>str}</em><em>, </em><em>{int</em><em>, </em><em>float</em><em>, </em><em>str}</em><em>...</em><em>]</em>) – Initial point.</p></li>
<li><p><strong>size</strong> (<em>str</em><em>, </em><em>default=None</em>) – Draw &lt;size&gt; neighbors of &lt;point&gt;.</p></li>
<li><p><strong>size</strong> – Draw a neighbor of &lt;point&gt; at dimension of label &lt;attribute&gt;</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>points</strong> – List of neighbors of &lt;point&gt;.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list[list[{int, float, str}, {int, float, str}…], …]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id9">
<span class="sig-name descname"><span class="pre">random_attribute</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">replace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#id9" title="Permalink to this definition"></a></dt>
<dd><p>Draw random features from the search space. Features of type K, cannot be drawn (i.e. their probability are set to 0).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>size</strong> (<em>int</em><em>, </em><em>default=1</em>) – Select randomly &lt;size&gt; features.</p></li>
<li><p><strong>replace</strong> (<em>boolean</em><em>, </em><em>default=True</em>) – Select randomly &lt;size&gt; features with replacement if True, without else.
See numpy.random.choice</p></li>
<li><p><strong>exclude</strong> (<em>str</em><em>, </em><em>default=None</em>) – Exclude dimension of label==&lt;exclude&gt; from the drawing.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>_</strong> – Array of selected dimension index.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.array(dtype=int)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id10">
<span class="sig-name descname"><span class="pre">random_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#id10" title="Permalink to this definition"></a></dt>
<dd><p>Return a random point from the search space</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>size</strong> (<em>int</em><em>, </em><em>default=1</em>) – Draw &lt;size&gt; points.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>points</strong> – List of neighbors of &lt;point&gt;.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list[list[{int, float, str}, {int, float, str}…], …]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id11">
<span class="sig-name descname"><span class="pre">random_value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attribute</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">replace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#id11" title="Permalink to this definition"></a></dt>
<dd><p>Draw random values of an attribute from the search space, using uniform distribution. Features of type K return their constant value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>attribute</strong> (<em>str</em>) – Select dimension of label==&lt;exclude&gt; from which to draw a random value.</p></li>
<li><p><strong>size</strong> (<em>int</em><em>, </em><em>default=1</em>) – Select randomly &lt;size&gt; features.</p></li>
<li><p><strong>replace</strong> (<em>boolean</em><em>, </em><em>default=True</em>) – Select randomly &lt;size&gt; features with replacement if True, without else.
See numpy.random.choice</p></li>
<li><p><strong>exclude</strong> (<em>str</em><em>, </em><em>default=None</em>) – Exclude dimension of label==&lt;exclude&gt; from the drawing.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>_</strong> – Array of floats for R dimension, ints for D, indexes (int) for C.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.array(dtype={int, float})</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id12">
<span class="sig-name descname"><span class="pre">show</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#id12" title="Permalink to this definition"></a></dt>
<dd><p>Show solutions X associated to their values Y, according to the Searchspace</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>list</em><em>[</em><em>list</em><em>[</em><em>{int</em><em>, </em><em>float</em><em>, </em><em>str}</em><em>, </em><em>{int</em><em>, </em><em>float</em><em>, </em><em>str}</em><em>...</em><em>]</em><em>, </em><em>...</em><em>]</em>) – List of points to plot</p></li>
<li><p><strong>Y</strong> (<em>list</em><em>[</em><em>{float</em><em>, </em><em>int}</em><em>]</em>) – Scores associated to X.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="id13">
<span class="sig-name descname"><span class="pre">subspace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">points</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sub_values</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#id13" title="Permalink to this definition"></a></dt>
<dd><p>Build a sub space according to the actual Searchspace using two vectors containing lower and upper bounds of the subspace.
Transforms types to K if necessary.
Builds an adaptated neighborhood to avoid large neighborhood compare to the subspace size.
Categorical lower and upper bounds of the subspace are determined according to a slice of the vector containing values:</p>
<blockquote>
<div><p>Original: [“dog”, “cat”, “rabbit”, “horse”]
lo_bounds = [“dog”]
up_bounds = [“rabbit”]
Subspace: [“dog”, “cat”, “rabbit”]</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lo_bounds</strong> (<em>{list</em><em>[</em><em>list</em><em>[</em><em>{int</em><em>, </em><em>float</em><em>, </em><em>str}</em><em>, </em><em>{int</em><em>, </em><em>float</em><em>, </em><em>str}</em><em>...</em><em>]</em><em>, </em><em>...</em><em>]</em><em>, </em><em>list</em><em>[</em><em>list</em><em>[</em><em>float</em><em>, </em><em>float</em><em>...</em><em>]</em><em>, </em><em>...</em><em>]</em><em>}</em>) – List of points to convert</p></li>
<li><p><strong>up_bounds</strong> (<em>boolean</em><em>, </em><em>default=False</em>) – If False convert points from mixed to continuous, if True, from continuous to mixed</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>subspace</strong> – Return a subspace of the actual Searchspace.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#zellij.utils.search_space.Searchspace" title="zellij.utils.search_space.Searchspace">Searchspace</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="zellij.utils.search_space.parallel_coordinates">
<span class="sig-prename descclassname"><span class="pre">zellij.utils.search_space.</span></span><span class="sig-name descname"><span class="pre">parallel_coordinates</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frame</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">class_column</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cols</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_columns</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xticks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colormap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#zellij.utils.search_space.parallel_coordinates" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</section>
<section id="zellij-utils-tree-search-module">
<h2>zellij.utils.tree_search module<a class="headerlink" href="#zellij-utils-tree-search-module" title="Permalink to this headline"></a></h2>
</section>
<section id="module-zellij.utils">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-zellij.utils" title="Permalink to this headline"></a></h2>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Thomas Firmin.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>